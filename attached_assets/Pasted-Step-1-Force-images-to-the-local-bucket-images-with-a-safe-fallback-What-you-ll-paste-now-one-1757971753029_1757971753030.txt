Step 1 — Force images to the local bucket (/images) with a safe fallback

What you’ll paste now (one file): make the confirmation API always return an imageUrl under /images, falling back to /images/placeholder.jpg. This prevents any external image from blanking the page.

Open: server/routes/orderSummaryById.js
Replace the entire file with this:

// server/routes/orderSummaryById.js
// GET /api/orders/:orderId/summary  → returns confirmation payload with local /images enforcement

const express = require('express');
const { readSnapshot, writeSnapshot } = require('../lib/storage');
const { splitOutcomes } = require('../lib/shippingSplit');
const { mintOrderNumber } = require('../lib/orderNumbers');

const router = express.Router();

router.get('/api/orders/:orderId/summary', (req, res) => {
  const orderId = String(req.params.orderId || '').trim();
  if (!orderId) return res.status(400).json({ error: 'orderId required' });

  const snap = readSnapshot(orderId);
  if (!snap) return res.status(404).json({ error: 'Order snapshot not found for this orderId' });

  // Normalize outcomes & mint once
  let outcomes;
  try { outcomes = splitOutcomes(snap.shippingOutcomes || ['IH>Customer']); }
  catch (e) { return res.status(400).json({ error: e.message }); }

  const minted = snap.minted || mintOrderNumber(outcomes);
  if (!snap.minted) {
    snap.minted = minted;
    snap.updatedAt = new Date().toISOString();
    writeSnapshot(orderId, snap);
  }

  // Validate required item fields and normalize imageUrl to /images base
  const items = Array.isArray(snap.items) ? snap.items.filter(Boolean) : [];
  const missing = [];
  const normalized = items.map((it, i) => {
    const sku = String(it.sku || '');
    const upc = String(it.upc || '');
    const mpn = String(it.mpn || '');
    const name = String(it.name || '');
    const qty = Number(it.qty || 1);
    const price = Number(it.price || 0);

    if (!sku) missing.push(`items[${i}].sku`);
    if (!upc) missing.push(`items[${i}].upc`);
    if (!mpn) missing.push(`items[${i}].mpn`);
    if (!name) missing.push(`items[${i}].name`);
    if (!(it.qty || it.qty === 0)) missing.push(`items[${i}].qty`);
    if (it.price === undefined || it.price === null) missing.push(`items[${i}].price`);

    // Enforce local bucket:
    // - If imageUrl already starts with /images, keep it.
    // - Else try deterministic UPC.jpg (or SKU.jpg), else placeholder.
    let url = String(it.imageUrl || '');
    const looksLocal = url.startsWith('/images/');
    if (!looksLocal) {
      if (upc) url = `/images/${upc}.jpg`;
      else if (sku) url = `/images/${sku}.jpg`;
      else url = '/images/placeholder.jpg';
    }

    return { sku, upc, mpn, name, qty, price, imageUrl: url };
  });

  if (missing.length) return res.status(422).json({ error: 'Snapshot incomplete for summary', fields: missing });

  const linesAll = normalized.map(toLineWithAliases);

  const parts = (minted.parts.length ? minted.parts : [{ outcome: outcomes[0], orderNumber: minted.main }]);
  const shipments = parts.map((p, idx) => {
    const shipLines = linesAll; // v1: same lines per shipment unless you pass allocations
    return { idx, outcome: p.outcome || outcomes[0], orderNumber: p.orderNumber || minted.main, lines: shipLines, totals: computeTotals(shipLines) };
  });

  const totals = computeTotals(linesAll);

  return res.json({
    orderId,                              // raw id (e.g., 129)
    orderNumber: minted.main,             // minted (e.g., 100007-0)
    order: {
      id: minted.main,
      number: minted.main,
      orderNumber: minted.main,
      idRaw: orderId
    },
    mainOrderNumber: minted.main,
    multiShipment: minted.parts.length > 0,
    lines: linesAll,
    shipments,
    customer: snap.customer || {},
    totals,
    status: snap.status || 'processing',
    txnId: snap.txnId || ''
  });
});

function toLineWithAliases(it) {
  const qty = Number(it.qty || 1);
  const unit = Number(it.price || 0);
  const url = String(it.imageUrl || '/images/placeholder.jpg');

  const base = {
    qty,
    pricingSnapshot: { retail: unit },
    unitPrice: unit,
    extendedPrice: round2(unit * qty),
    product: {
      sku: it.sku,
      upc: it.upc,
      mpn: it.mpn,
      name: it.name,
      image: { url },
      imageUrl: url
    }
  };

  // Line-level aliases (legacy reads)
  base.sku = it.sku;
  base.upc = it.upc;
  base.mpn = it.mpn;
  base.name = it.name;
  base.imageUrl = url;

  return base;
}

function computeTotals(lines) {
  const sub = lines.reduce((s, ln) => s + Number(ln.extendedPrice || 0), 0);
  return { subtotal: round2(sub), tax: 0, shipping: 0, grandTotal: round2(sub) };
}
function round2(n) { return Math.round(Number(n) * 100) / 100; }

module.exports = router;