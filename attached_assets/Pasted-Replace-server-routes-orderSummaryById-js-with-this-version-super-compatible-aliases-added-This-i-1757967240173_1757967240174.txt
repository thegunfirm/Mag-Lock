Replace server/routes/orderSummaryById.js with this version (super-compatible aliases added). This is the only change.

// server/routes/orderSummaryById.js
// GET /api/orders/:orderId/summary  -> returns the shape the frozen UI expects + broad compatibility aliases

const express = require('express');
const { readSnapshot, writeSnapshot } = require('../lib/storage');
const { splitOutcomes } = require('../lib/shippingSplit');
const { mintOrderNumber } = require('../lib/orderNumbers');

const router = express.Router();

router.get('/api/orders/:orderId/summary', (req, res) => {
  const orderId = String(req.params.orderId || '').trim();
  if (!orderId) return res.status(400).json({ error: 'orderId required' });

  const snap = readSnapshot(orderId);
  if (!snap) return res.status(404).json({ error: 'Order snapshot not found for this orderId' });

  // Normalize outcomes & mint once
  let outcomes;
  try { outcomes = splitOutcomes(snap.shippingOutcomes || ['IH>Customer']); }
  catch (e) { return res.status(400).json({ error: e.message }); }

  const minted = snap.minted || mintOrderNumber(outcomes);
  if (!snap.minted) {
    snap.minted = minted;
    snap.updatedAt = new Date().toISOString();
    writeSnapshot(orderId, snap);
  }

  // Enforce required fields so UI never renders blanks silently
  const items = Array.isArray(snap.items) ? snap.items.filter(Boolean) : [];
  const missing = [];
  items.forEach((it, i) => {
    if (!it.upc) missing.push(`items[${i}].upc`);
    if (!it.mpn) missing.push(`items[${i}].mpn`);
    if (!it.sku) missing.push(`items[${i}].sku`);
    if (!it.name) missing.push(`items[${i}].name`);
    if (it.price === undefined || it.price === null) missing.push(`items[${i}].price`);
    if (!it.imageUrl) missing.push(`items[${i}].imageUrl`);
    if (!it.qty && it.qty !== 0) missing.push(`items[${i}].qty`);
  });
  if (missing.length) {
    return res.status(422).json({ error: 'Snapshot incomplete for summary', fields: missing });
  }

  // Build full-cart lines + add compatibility aliases at both line AND product level
  const linesAll = items.map(toLineWithWideAliases);

  // Per-shipment (Amazon-style) using optional allocations
  const parts = (minted.parts.length ? minted.parts : [{ outcome: outcomes[0], orderNumber: minted.main }]);
  const alloc = (snap.allocations && typeof snap.allocations === 'object') ? snap.allocations : null;

  const shipments = parts.map((p, idx) => {
    const shipItems = itemsForOutcome(p.outcome || outcomes[0], items, alloc);
    const shipLines = shipItems.map(toLineWithWideAliases);
    return {
      idx,
      outcome: p.outcome || outcomes[0],
      orderNumber: p.orderNumber || minted.main,
      lines: shipLines,
      totals: computeTotals(shipLines)
    };
  });

  const totals = sumTotals(shipments.map(s => s.totals));

  // Top-level + nested "order" aliases for maximum compatibility
  return res.json({
    orderId,                              // original numeric/string id (e.g., 129)
    orderNumber: minted.main,             // primary minted number (e.g., 100007-0)
    orderNumberText: minted.main,         // alias
    order: {
      id: minted.main,                    // some UIs show order.id
      number: minted.main,                // some UIs show order.number
      orderNumber: minted.main,           // some UIs show order.orderNumber
      idRaw: orderId                      // keep raw query id for debugging
    },
    mainOrderNumber: minted.main,         // retained for other consumers
    multiShipment: minted.parts.length > 0,
    lines: linesAll,                      // UI iterates this
    shipments,                            // Amazon-style splits
    customer: snap.customer || {},
    totals,
    status: snap.status || 'processing',
    txnId: snap.txnId || ''
  });
});

function toLineWithWideAliases(it) {
  const qty = Number(it.qty || 1);
  const unit = Number(it.price || 0);
  const url = String(it.imageUrl || '');
  const sku = String(it.sku || '');
  const upc = String(it.upc || '');
  const mpn = String(it.mpn || '');
  const name = String(it.name || '');

  const product = {
    sku,
    upc,
    mpn,
    name,
    image: { url },
    // ⬇︎ product-level alias many legacy UIs use
    imageUrl: url,
    // ⬇︎ occasionally legacy code references uppercase keys
    UPC: upc,
    MPN: mpn,
    SKU: sku,
    NAME: name
  };

  const line = {
    qty,
    pricingSnapshot: { retail: unit },
    unitPrice: unit,
    extendedPrice: round2(unit * qty),
    product
  };

  // Line-level aliases (legacy reads on line object itself)
  line.imageUrl = url;
  line.upc = upc;
  line.mpn = mpn;
  line.sku = sku;
  line.name = name;

  return line;
}

function itemsForOutcome(outcome, items, allocations) {
  if (!allocations || !allocations[outcome]) return items;
  const a = allocations[outcome];
  if (!Array.isArray(a) || !a.length) return [];
  if (typeof a[0] === 'number') return a.map(i => items[i]).filter(Boolean);
  // selector objects
  return a.map(sel => {
    const found = items.find(it =>
      (sel.sku && it.sku === sel.sku) ||
      (sel.upc && it.upc === sel.upc) ||
      (sel.mpn && it.mpn === sel.mpn)
    );
    if (!found) return null;
    return { ...found, qty: (sel.qty ?? found.qty) };
  }).filter(Boolean);
}

function computeTotals(lines) {
  const sub = lines.reduce((s, ln) => s + Number(ln.extendedPrice || 0), 0);
  return { subtotal: round2(sub), tax: 0, shipping: 0, grandTotal: round2(sub) };
}
function sumTotals(list) {
  return list.reduce((acc, t) => ({
    subtotal: round2((acc.subtotal||0) + (t.subtotal||0)),
    tax: round2((acc.tax||0) + (t.tax||0)),
    shipping: round2((acc.shipping||0) + (t.shipping||0)),
    grandTotal: round2((acc.grandTotal||0) + (t.grandTotal||0)),
  }), { subtotal:0,tax:0,shipping:0,grandTotal:0 });
}
function round2(n) { return Math.round(Number(n) * 100) / 100; }

module.exports = router;